- `<?php ?>` で PHP のコードを書ける
  - 以降にその他のタグや出力が無い場合、終了タグ(`?>`)は省略可能
- `$ php -S <ip>[:<port>]` でビルトインサーバの起動
- 変数の定義
  - `$xxxx` のように先頭 `$` で変数を表現
- 変数の型
  - `string`
  - `integer`
  - `float`
  - `boolean`
  - 配列
  - オブジェクト
  - `null`
- [`var_dump`](https://www.php.net/manual/ja/function.var-dump.php) で変数の情報を取得可能
  - `var_dump(1)` -> `int(1)`
  - `var_dump(1.5, "2")` -> `float(1.5) string(1) "2"`
- 定数の宣言
  - `define(key, value);` で定数の宣言
    - `define("MY_EMAIL", "my@email.com");
  - 参照時に `$` をつける必要はない
- 特殊定数
  - 行数などの定数は最初から用意されている
    - `__DIR__`
    - `__FILE__`
    - `__LINE__`
    - `__CLASS__`
    - `__FUNCTION__`
    - `__METHOD__`
    - `__NAMESPACE__`
- 演算子
  - `+`, `-`, `*`, `/`, `%`
  - `**`: べき乗
    - `10 ** 3 => 1000`
  - `++`, `--`
  - `+=`, `-=`, `/=`, `*=`
- 文字列
  - `""`: ダブルクォーテーションだと変数展開や `\t` などの特殊文字を扱える
    - `{}` で囲んで変数の範囲を表現することが可能(shell っぽい感じ)
      - `${hoge}` でも `{$hoge}` でもどっちでも
  - `''`: シングルクォーテーションだと変数展開などができない
  - `.` で文字列連結
    - `"hello" . "world"` で `"helloworld` になる
- `if/elseif/else` で条件分岐
  - `==`: 値のみ比較
  - `===`: 値 + 型 で比較
- データの値で真偽判定できる
  - `false` になるケース
    - 文字列: 空(`""), `"0"`
    - 数値: `0`, `0.0`
    - 配列: 要素の数が 0
- `switch/case` で条件分岐
  - `switch (<target>)`
  - `case <condition>:`
    - `break` が必要
- `while`, `do/while`, `foo` でループ処理
  - `break`, `continue`
- 配列は `array()` もしくは `[]` で定義
  - 中身は `<key> => <value>` で宣言
  - `<key>` を省略した場合は他言語同様に `0, 1, 2, ..` となる
- `foreach` で配列の要素を順に取り出せる
  - `foreach (<array> as <key> => <value>)`: `key => value` で定義した場合
  - `foreach (<array> as <value>)`: `value` のみで定義した場合
  - `foreach( ... ) { ...; }` は `foreach( ... ) : ...; endforeach;` とも書ける
    - HTML タグと合わせて書く際に対応関係がわかりやすくなる
- 関数は `function funcName(args) {}` で定義
  - デフォルト引数も設定可能
  - ローカル変数のスコープはネストに影響されない
- クラスとインスタンス
  - `class <class name> {}` でクラスの定義
    - プロパティやメソッドのスコープを `public`, `private`, `protected` で指定
    - `static` でクラス変数やクラスメソッドを定義
      - 呼び出しは `MyClass::myStaticFunc()` と `::` 区切り
      - プロパティは `MyClass::$myStaticProperty` と `::$` 区切り
      - クラス内からは `self::myStaticFunc()` や `self::$myStaticProperty`
    - クラス内からプロパティなどにアクセスする場合は `$this->property` という感じに `$this` を使う
    - コンストラクタは `__construct` で宣言
    - 継承は `extends SuperClass` で実施
      - 同名のプロパティやメソッドを定義してオーバーライドもできる
        - オーバーライドを防ぐには `final` 修飾子をつけてメソッドを定義する
          - `final public methodName`
  - `$instance = new MyClass()` でインスタンスの作成
  - `$instance->name`, `$instance->func()` でプロパティやメソッドへのアクセス
- 抽象クラスは `abstract class` で定義
  - メソッドに `abstract` 修飾子をつけることで、子クラスでの実装が必須となる
- `interface` でインターフェースの定義
  - 実装が必要なクラスに対して `implements MyInterface, MyInteface2, ...` で指定
  - 抽象クラスは実装必須でないプロパティやメソッドも定義可能
- 別ファイルを読み込むには `require` などを利用
  - `require`, `require_once`
    - エラー発生時: Fatal error
  - `include`, `include_once`
    - エラー発生時: Warning
  - `autoload` *クラスのみ
- 名前空間は `namespace` で定義
  - `namespace hoge\fuga;` のようにバックスラッシュ(`\`)区切りで表現
    - 必ずファイル先頭に記載する
  - 参照側でも同様にバックスラッシュ(`\`)区切りでアクセス
    - `new hoge\fuga\User();` など
    - `use hoge\fuga as piyo` とすることで `new piyo\User();` のように省略(別名でアクセス)できる
    - `use hoge\fuga` と `as xxxx` を省略した場合、末尾の `fuga` でアクセス可能(`new fuga\User();`)
- 例外処理は `try/catch` で処理
  - `catch` した例外に対して `$e->getMessage()` でエラーメッセージの表示(取得)
  - `throw new xxxxException("Your Message);` で例外を発生されることができる
- `$_SERVER["REQUET_METHOD"]` で HTTP Method を取得
  - POST のデータは `$_POST["key"]` でアクセス可能
  - `input` タグの `value` 属性に値を設定する場合は [`htmlspecialchars`](https://www.php.net/manual/ja/function.htmlspecialchars.php) を使う
    - `htmlspecialchars($username, ENT_QUOTES, 'UTF-8')`
- Cookie を使うには `setcookie` や `$_COOKIE["key"]` を使う
  - 登録(作成): `setcookie(key, value[, expiration])`
    - `expiration` に `time() + 60 * 60` で 1時間有効
      - 省略時はブラウザが閉じられるまで
  - 参照: `$_COOKIE[key]`
  - 削除: `setcookie(key, value, time() - 60)`
    - expiration に過去の値を設定
- `session_start()` セッション開始
  - `$_SESSION[key] = value` でセッション作成
  - `unset($_SESSION[key])` でセッション削除
